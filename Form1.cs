using System;
using System.Drawing;
using System.Windows.Forms;

namespace Breakout //пространство имён соответствует названию проекта
{
    public partial class Breakout : Form  //создается частичный класс
    {//другая часть определения класса находится в файле Designer
        //объявляем локальные поля класса (по умолчанию доступны только внутри класса)
        //логические переменные:
        bool goLeft; //сообщает, двигается ли игрок влево
        bool goRight; //сообщает, двигается ли игрок вправо
        bool isGameOver; //сообщает, завершена ли игра
        bool isPaused; //сообщает, находится ли игра на паузе
        bool recordBreak; //сообщает, побит ли рекорд
        //целочисленные переменные:
        int score; //отвечает за количество очков, набранных игроком
        int ballx; //отвечает за скорость движения шарика по оси х
        int bally; //отвечает за скорость движения шарика по оси y
        int playerSpeed; //отвечает за скорость передвижения игрока
        int ballSpeed; //отвечает за общую скорость движения шарика
        int highscore; //отвечает за максимально набранное игроком количество очков

        Random rnd = new Random(); //создаем новый экземпляр класса Random (потребуется для генерации случайных чисел)

        PictureBox[] blockArray; //создаем экземпляр класса PictureBox, через него впоследствии будем создавать блоки

        public Breakout() //конструктор класса Breakout
        {
            InitializeComponent(); //вызов метода из другой части определения класса, создаётся автоматически для инициализации компонентов

            placeBlocks(); //вызов метода, который устанавливает блоки на экране
        }

        private void placeBlocks() //метод, устанавливающий уничтожаемые шариком блоки
        {
            blockArray = new PictureBox[20]; //всего на экране может находиться до 20 блоков
            //локальные переменные метода:
            int line = 0; //отвечает за количество уже установленных в один ряд блоков (максимум 5)
            int top = 50; //отступ от верхней границы окна (в пикселях)
            int left = 100; //отступ от левой границы окна (в пикселях)

            for (int i = 0; i < blockArray.Length; i++) //цикл, в котором происходит заполнение поля blockArray
            { //и вывод на экран блоков
                blockArray[i] = new PictureBox(); //создаем новый PictureBox на экране (это и есть уничтожаемый блок)
                blockArray[i].Height = 25; //высота одного блока - 25 пикселей
                blockArray[i].Width = 100; //длина одного блока - 100 пикселей
                blockArray[i].Tag = "blocks"; //взаимодействие с формой осуществляется через тэги, задаем объект blocks
                blockArray[i].BackColor = Color.White; //изначально все блоки создаем белого цвета


                if (line == 5) //если уже создано 5 блоков в одном ряду
                {
                    top += 35; //увеличиваем отступ от верхней границы клиентской области
                    left = 100; //отступ от левой границы возвращаем к начальному значению
                    line = 0; //обнуляем количество установленных блоков в ряду (так как перешли на новый ряд)
                }

                if (line < 5) //если 5 блоков еще не создано
                {
                    line++; //увеличиваем счётчик установленных блоков
                    blockArray[i].Left = left; //задаём отступ слева для блока
                    blockArray[i].Top = top; //задаём отступ сверху для блока
                    this.Controls.Add(blockArray[i]); //добавляем блок на форму со всеми ранее заданными параметрами (в коллекцию элементов управления)
                    left += 130; //увеличиваем отступ от левой границы на 130 пикселей (длина одного блока 100 пикселей + оставляем небольшое пространство между блоками)
                }

            }
            specialMessage.Text = null; //очищаем лейбл для сообщений от текста (пригодится позже для отображения паузы)
            if (score == 0 || isGameOver) //если счёт равен нулю (первый запуск игры) или же игра была завершена (последующие запуски)
                setupGame(); //запускаем метод установки параметров игры
        }

        private void setupGame() //метод, задающий начальные параметры для игры
        {
            isGameOver = false; //игра запускается, значит логической переменной, отвечающей за конец игры, необходимо присвоить значение 0
            recordBreak = false; //по умолчанию устанавливаем, что рекорд не побит
            score = 0; //игра всегда начинается с нуля очков
            ballx = 5; //задаём начальное значение скорости передвижения шарика по оси x (скорость положительная, шарик движется вправо)
            bally = 5; //чтобы шарик сначала попал на платформу, задаём положительную скорость по оси y, таким образом он будет двигаться вниз, в сторону платформы игрока
            playerSpeed = 12; //скорость передвижения платформы, которой управляет игрок
            ballSpeed = 0; //параметр скорости шарика (при нуле скорость при каждом соприкосновении с платформой будет случайной)
            txtScore.Text = "Счёт: " + score; //устанавливаем в лейбле для отображения количества очков, набранных игроком, надпись "Счёт" и значение переменной, хранящей количество очков
            ball.Left = 376; //задаём начальное положение шарика: отступ от левой границы клиентской области
            ball.Top = 328; //отступ от верхней границы клиентской области
            player.Left = 347; //задаём начальное положение платформы: отступ от левой границы клиентской области, отступ от верхней границы всегда остается неизменным

            gameTimer.Start(); //запускаем таймер, описание действий, выполняемых на каждом тике таймера, находится в методе mainGameTimer
            colorBlocks(); //запускаем метод, выполняющий окраску блоков в разные цвета
        }

        private void colorBlocks() //метод, раскрашивающий блоки
        {
            foreach (Control x in this.Controls) //в цикле для каждого элемента управления из коллекции элементов управления
            {
                if (x is PictureBox && (string)x.Tag == "blocks") //если элемент управления является PictureBox и его тэг хранит значение blocks
                {
                    x.BackColor = Color.FromArgb(rnd.Next(256), rnd.Next(256), rnd.Next(256)); //меняем цвет случайным образом через задание 8-разрядных значений красного, зеленого и синего цветов (rgb)
                } //rnd.Next(256) означает, что мы выбираем случайное целое число из диапазона (0,255)
            }
        }

        private void removeBlocks() //метод, удаляющий блоки
        { //используется при перезапуске игры и обновлении блоков после уничтожения шариком всех 20 блоков на экране
            foreach (PictureBox x in blockArray) //цикл для каждого PictureBox в поле blockArray
            {
                this.Controls.Remove(x); //удаляем элемент из коллекции
            }
        }

        private void mainGameTimer(object sender, EventArgs e) //метод, описывающий действия на каждом тике таймера (интервал 20 мс)
        {
            if (goLeft && player.Left > 0) //если логическая переменная содержит информацию о том, что пользователь хочет направить платформу влево
            { //и платформа имеет отступ от левой границы клиентской области
                player.Left -= playerSpeed; //смещаем платформу влево с заданной скоростью
            }
            if (goRight && player.Left < 700) //если логическая переменная содержит информацию о том, что пользователь хочет направить платформу вправо
            { //и платформа имеет отступ от левой границы клиентской области в менее чем 700 пикселей
                player.Left += playerSpeed; //смещаем платформу вправо с заданной скоростью
            }

            ball.Left += ballx; //задаём движение по оси x для левой границы шарика
            ball.Top += bally; //движение по оси y для верхней границы

            if (ball.Left < 0 || ball.Left > 775) //если шарик доходит до левой или правой границы клиентской области
            {
                ballx = -ballx; //меняем направление движения по оси x на противоположное
            }
            if (ball.Top < 0) //если шарик доходит до верхней границы клиентской области
            {
                bally = -bally; //меняем направление движения по оси y на противоположное
            }

            if (ball.Bounds.IntersectsWith(player.Bounds)) //если шарик пересекается с платформой
            { //определяется пересечение двух прямоугольников - шарика и платформы, учитывается пересечение хотя бы одного пикселя
                ball.Top = 463; //шарик выталкивается наверх и устанавливается над платформой
                if (ballSpeed == 0) //если значение скорости шарика установлено по умолчанию
                    ballSetSpeed(rnd.Next(5, 12)); //задаем случайное значение скорости
                else
                    ballSetSpeed(ballSpeed); //иначе устанавливаем в соответствии с заданным значением скорости
                if (score != 0 && score % 20 == 0) //если шарик уничтожил все 20 блоков
                { //то при следующем соприкосновении с платформой
                    removeBlocks(); //произойдет удаление информации о старых блоках из коллекции элементов управления
                    placeBlocks(); //в коллекцию добавится 20 новых блоков (все белого цвета), они будут установлены на форме
                    colorBlocks(); //установленные блоки нужно отдельно раскрасить в случайные цвета
                }
            }
            //нужно также сделать обработку пересечения шарика с блоками и их удаления
            foreach (Control x in this.Controls) //для каждого элемента управления из коллекции
            {
                if (x is PictureBox && (string)x.Tag == "blocks") //если он является PictureBox и имеет тэг blocks
                {
                    if (ball.Bounds.IntersectsWith(x.Bounds)) //если шарик пересекается с блоком (пересечение двух прямоугольников)
                    { //это означает что шарик достиг своей цели
                        score += 1; //нужно увеличить счётчик уничтоженных блоков
                        txtScore.Text = "Счёт: " + score; //обновляем значение счёта в лейбле
                        if (score > highscore) //если счёт превышает рекордный
                        {
                            highscore = score; //начинаем обновлять значение рекорда
                            hghscore.Text = "Рекорд: " + highscore; //в том числе в лейбле
                            if (!recordBreak) recordBreak = true; //и считаем, что рекорд побит
                        }
                        bally = -bally; //шарик отталкивается от блока и начинает двигаться в противоположном направлении по оси y
                        this.Controls.Remove(x); //блок удаляется с экрана
                    }
                }
            }

            if (score == 220) //максимально возможное количество очков
            {
                gameOver("Победа! Для продолжения нажмите Enter..."); //запускаем метод обработки завершения игры, передаем сообщение о победе
            }

            if (ball.Top > 580) //условие завершения игры - шарик оказался за клиентской областью (нижняя грань)
            {
                if (recordBreak) //если по итогам игры рекорд побит
                    specialMessage.Text = "Новый рекорд!"; //выводим соответствующее сообщение на экран
                gameOver("Вы програли! Для продолжения нажмите Enter..."); //запускаем метод обработки завершения игры, передаем сообщение о проигрыше
            }
        }

        private void gameOver(string message) //метод обработки завершения игры
        {
            isGameOver = true; //значение логической переменной должно сообщать о том, что игра завершена
            gameTimer.Stop(); //останавливаем таймер
            txtScore.Text = "Счёт: " + score + " " + message; //добавляем к счёту на экране сообщение о том, что игра завершена
        }

        private void ballSetSpeed (int speed) //метод, устанавливающий скорость шарика при взаимодействии с платформой
        { //по оси y изменяем скорость на противоположную, по оси x оставляем направление не изменяется
            bally = speed * -1; //изменяем скорость шарика по оси y на противоположную
            if (ballx < 0) //если шарик движется влево по оси x
                ballx = speed * -1; //значит нам нужно установить отрицательную скорость
            else //если шарик движется вправо
                ballx = speed; //оставляем скорость положительной
        }

        public void keyisdown(object sender, KeyEventArgs e) //метод обработки событий при зажатой клавише
        {
            if (e.KeyCode == Keys.Left) //обработка удержания стрелки влево
            {
                goLeft = true; //значение булевой переменной должно сообщать о том, что пользователь хочет направить платформу влево
            }
            if (e.KeyCode == Keys.Right) //обработка удержания стрелки вправо
            {
                goRight = true; //значение булевой переменной должно сообщать о том, что пользователь хочет направить платформу вправо
            }
        }

        public void keyisup(object sender, KeyEventArgs e) //метод обработки событий после того как клавиша была нажата
        {
            if (e.KeyCode == Keys.Left) //обработка отпущенной клавиши стрелка влево
            {
                goLeft = false; //значение булевой переменной теперь сообщает о том, что платформа перестала двигаться влево
            }
            if (e.KeyCode == Keys.Right) //обработка отпущенной стрелки вправо
            {
                goRight = false; //значение булевой переменной теперь сообщает о том, что платформа перестала двигаться вправо
            }
            if (e.KeyCode == Keys.Enter && isGameOver) //если игра закончена и мы хотим начать новую, нужно нажать клавишу Enter
            {
                removeBlocks(); //запускается метод удаления старых блоков на экране
                placeBlocks(); //запускается метод создания новых блоков, из него запускаются другие методы, необходимые для начала игры
            }
            if (e.KeyCode == Keys.Escape) //обработка нажатия клавиши Escape
            {
                if (!isGameOver) //если игра не завершена
                {
                    if (!isPaused) //если игра не находится на паузе
                    {
                        gameTimer.Stop(); //останавливаем таймер и, соответственно, игру
                        specialMessage.Text = "Пауза"; //выводим на экран сообщение о том, что игра приостановлена
                        isPaused = true; //меняем значение логической переменной, теперь она означает, что игра на паузе
                    }
                    else //если игра уже находится на паузе
                    {
                        specialMessage.Text = null; //удаляем сообщение о паузе с экрана
                        isPaused = false; //меняем значение логической переменной, чтобы она могла сообщить, что игра не на паузе
                        gameTimer.Start(); //и обратно запускаем таймер
                    }
                }
                else //если игра завершена
                {
                    Application.Exit(); //по нажатии Esc произойдет выход из игры
                }
            }
            //клавишами 0,1,2,3 регулируется сложность игры (0 - случайная, 1 - лёгкая, 2 - средняя, 3 - сложная)
            if (e.KeyCode == Keys.D1) { ballSpeed = 5; } //после нажатия клавиши 1 переменная, отвечающая за скорость движения шарика принимает минимальное значение
            if (e.KeyCode == Keys.D2) { ballSpeed = 8; } //после нажатия клавиши 2 скоростная переменная принимает среднее значение
            if (e.KeyCode == Keys.D3) { ballSpeed = 12; } //после нажатия клавиши 3 скоростная переменная принимает максимально возможное значение
            if (e.KeyCode == Keys.D0) { ballSpeed = 0; } //при нажатии клавиши 0 скорость движения шарика вернется к стандартной (случайной при каждом соприкосновении с платформой)
        }
    }
}
